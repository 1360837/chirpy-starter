[
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스] Ch02 정점 처리",
    "url": "/posts/3Dgraphics-ch02/",
    "categories": "",
    "tags": "graphics, vertex, pipeline, redering",
    "date": "2025-05-28 22:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch02 정점 처리  2.1 월드 변환  2.2 뷰 변환  2.3 정점별 조명  2.4 투영 변환cha...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch02 정점 처리  2.1 월드 변환  2.2 뷰 변환  2.3 정점별 조명  2.4 투영 변환chap 02 정점 처리  파이프라인: 한 단계의 출력이 다음 단계의 입력으로 사용되는 일련의 데이터 처리 구조GPU의 렌더링 파이프라인은 주로 폴리곤으로 구성된 3차원 장면을 입력으로 받아서, 각각의 폴리곤을 2차원 형태로 바꾸고, 2차원 폴리곤 내부를 차지하는 픽셀(pixel)의 색깔을 결정하여 3차원 장면의 최종 영상을 생성한다.렌더링 파이프라인을 구성하는 네 가지 주요 요소정점 처리(vertex processing): 정점 버퍼에 저장된 모든 정점에 대해 작동하며, 변환(transform)을 비롯한 다양한 정점별 연산을 수행한다.래스터화(rasterization): 변환된 정점에 의해 정의된 폴리곤의 내부를 차지하는 프래그먼트(fragment)를생성한다.  픽셀과 프래그먼트의 관계  화면을 구성하는 픽셀 전체는 컬러 버퍼(color buffer)라는 메모리 공간에 저장되는데, 한 화면을 생성하기 위해 이 컬러 버퍼는 여러 차례 수정된다. 이 수정 과정은 픽셀별로 진행되는데, 현재 컬러 버퍼에 저장된 픽셀을 수정하는데 필요한 데이터 모음을 프래그먼트라 부른다.프래그먼트 처리(fragment processing): 레스터화 단계에서 출력된 프래그먼트는 하나하나 프래그먼트 처리 단계로 입력되어, 여러 작업을 거쳐 색상이 결정된다.출력 병합(output merging): 이러한 프래그먼트와 현재 컬러 버퍼에 저장된 픽셀 중 하나를 선택하거나 혹은 이들의 색상을 결합하여 컬러 버퍼를 수정한다.렌더링 파이프라인의 각 단계는 프로그래밍 가능한(programmable) 단계와 하드웨어로 고정된(fixed 혹은 hardwired) 단계로 구분된다.정점 처리 및 프래그먼트 처리 단계는 프로그래밍 가능하다.  정점 프로그램(vertex program): 사용자가 원하는 임의의 변환을 정점에 적용할 수 있도록 해주는 프로그램  프래그먼트 프로그램(fragment program): 사용자가 원하는 임의의 방법을 사용하여 프래그먼트의 색상을 결정할 수 있도록 해주는 프로그램래스터와 및 출력 병합 단계는 고정되어 있다."
  },
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스] Ch01-4 좌표계",
    "url": "/posts/3Dgraphics-ch01-4/",
    "categories": "",
    "tags": "graphics, vector, coordinate",
    "date": "2025-05-25 15:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계1.4 좌표계(좌) 오른손 좌표계, (우) 왼손 좌표계오른손 좌표계와 왼손 좌표계오른손·왼손 네 손가락이 \\(x\\)축에서 \\(y\\)축 방향으로 감싸며 움직일 때 엄지손가락이 \\(z\\)축 방향을 가리키게 된다.  1.2.3절에서 암묵적으로 오른손 좌표계를 가정하였고, 삼각형 노멀을 정의하기 위해 오른손을 사용했다. 하지만 왼손 좌표계에서는 왼손을 사용해 삼각형 노멀을 정의한다.  오른손 좌표계에서는 삼각형 정점은 반시계 방향으로 정렬되지만, 왼손 좌표계에서는 시계 방향으로 정렬되어야 한다.오른손 좌표계와 왼손 좌표계에서의 정점 정렬하나의 폴리곤 메쉬를 오른손 좌표계와 왼손 좌표계 사이에서 포팅할 때는 일종의 리모델링(remodeling) 작업이 필요하다.삼각형과 사각형으로 구성된 간단한 물체가 오른손 좌표계에서 -z축 방향에 정의되어 있다.이러한 물체를 렌더링하기 위해서는 우리 눈에 해당하는 가상 카메라의 위치 및 시선(view direction)등과 같은 파라미터를 정해야 한다.(2장 내용)카메라의 위치가 원점이고, 시선은 (0,0,-1) 방향이라고 가정하면, 우측 상자에 보이는 영상을 만들어낸다.이제 위 이미지 (a)의 물체를 왼손 좌표계 기반의 패키지로 그대로 포팅되었다고 가정하자.이 물체는 위 이미지 (b)와 같이 왼손 좌표계의 -z축 방향에 놓이게 된다.(a)의 이미지의 오른손 좌표계와 같이 카메라의 위치와 시선을 그대로 사용되었다고 가정하자.그 결과 우측 상자에 보이는 영상을 얻을 수 있다.(a) 이미지의 영상과 비교해 보면 좌우가 뒤바뀌어졌음을 알 수 있다.이러한 불일치를 해결하는 방법은 간단하다. 내보내기 시 물체와 카메라 파라미터의 -z 좌표의 부호를 바꾸면 된다.이는 xy평면에 대한 반사(reflection)에 해당한다.이 과정이 바로 두 번째 리모델링 작업이다.(c) 이미지는 이렇게 반사 된 물체와 카메라 파라미터를 보여준다.그러면 (a) 이미지와 동일한 영상을 생성한다."
  },
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스] Ch01-3 모델 내보내기와 불러오기",
    "url": "/posts/3Dgraphics-ch01-3/",
    "categories": "",
    "tags": "graphics, modeling, import, export, plug-in, script",
    "date": "2025-05-23 15:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계1.3 모델 내보내기와 불러오기오프라인에서 만들어진 객체와 애니메이션 데이터 등은 파일에 저장되어 런타임 게임 프로그램으로 넘겨진다.내보내기(export): 하나의 응용에서 만들어진 데이터를 다른 응용에 적합한 형태로 출력하는 과정불러오기(import): 출력된 데이터를 읽어오는 과정내보내기는 플러그인(plug-in)이나 스크립트(script)를 사용해 수행된다.  호스트(host): 모델링을 위해 사용되는 기본 프로그램(ex. 3dx Max)플러그인은 호스트가 직접 지원하지 않는 기능을 제공하여 호스트에 더해지는 프로그램이다.플러그인은 기계어로 컴파일된 후 CPU에 의해 실행된다.스크립트는 대개 호스트 프로그램에 의해 번역(interpret)되어 실행된다.그래픽스 패키지는 고유의 스크립트 언어를 제공하며, 스크립트는 해당 호스트에 특화된 언어이므로 플로그인에 비해 그 용도가 제한적이다.플러그인에 비해 대체로 느린 단점이 있지만, 작성하기 쉽고 호스트에 최적화된 방식으로 접근할 수 있다는 장점이 있다.인덱스 삼각형 리스트를 내보내는 스크립트의 수도코드Specify Out as the output fileforeach polygon mesh    Write the number of vertices to Out    foreach vertex         Write its positions and normals to Out    endforeach    Write the number of polygons to Out    foreach polygon        Write its three indices to Out    endforeachendforeach실제 출력된 텍스트 파일의 일부vertices 53049.2721 0.809525 85.6266 -0.966742 0.0 0.25575248.5752 0.809525 88.2606 -0.966824 0.0 0.25544449.3836 0.809525 89.1386 -0.092052 0.0 0.995754…faces 10240 5 66 1 0…530개의 정점과 1024개의 삼각형으로 구성된 폴리곤 메쉬인덱스 삼각형 리스트로 표현된 폴리곤 메쉬는 보통 두 개의 CPU 배열로 로딩되는데, 각 각 정점과 인덱스를 저장한다.이 배열들을 GPU 메모리로 옮기기 위해 일련의 그래픽스 API 함수들이 호출되고, 최종적으로 GPU는 이 폴리곤 메쉬를 렌더링하게 된다."
  },
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스] Ch01-2 폴리곤 메쉬",
    "url": "/posts/3Dgraphics-ch01-2/",
    "categories": "",
    "tags": "graphics, polygon_mesh, modeling, vector",
    "date": "2025-05-16 15:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계1.2 폴리곤 메쉬3차원 컴퓨터 그래픽스에서는 다양한 모델링 기법이 사용된다.중심이 \\((C_x, C_y, C_z)\\)에 있고 반지름이 r인 구(sphere)을 생각해보자.이를 표현하는 가장 간단한 방법은 \\(f(x,y,z)=0\\) 형태의 음함수(implicit function)를 사용하는 것이다.폴리곤 메쉬는 정점(vertex) 등과 같은 위상적(topological) 요소들을 명시적으로 정의하여 구를 표현한다.(좌) 음함수 곡면, (우) 폴리곤 메쉬GPU가 폴리곤 메쉬 처리에 최적화되어 있기 때문에 실시간 응용에서는 폴리곤 메쉬 표현을 선호한다.폴리곤 메쉬의 정점들은 부드러운 곡면을 샘플링(sampling)한 점들에 불과하다.폴리곤 메쉬는 정확한 표현법이 아닌 근사적(appoximate) 표현법이다.Direct3D에서 폴리곤 메쉬는 삼각형 메쉬(triangle mesh)를 의미한다.  Direct3D가 처리할 수 있는 폴리곤은 삼각형으로 제한된다.  OpenGl은 임의의 수의 정점을 가지는 (볼록)폴리곤을 처리할 수 있다.(좌) 삼각형 메쉬, (우) 사각형 메쉬  일반적으로 삼각형 메쉬가 보다 널리 쓰이지만 모델링 작업 등을 위해서는 사각형 메쉬가 선호된다.부드러운 곡면을 근사적으로 표현하는 폴리곤 메쉬는 다양한 해상도(resolution)로 표현될 수 있다.해상도를 결정할 때에는 정확성과 효율성 사이에 적절한 타협점을 찾아야 한다.해상도가 올라갈수록 본래의 곡면과 흡사해지지만 효율성은 떨어지게 된다.세분화(refinement): 저해상도 메쉬를 고해상도 메쉬로 변환하는 과정간략화(simplification): 고해상도 메쉬를 저해상도 메쉬로 변환하는 과정다양한 해상도의 폴리곤 메쉬1.2.1 폴리곤 메쉬 제작  그래픽 아티스트가 수행해야 할 작업이기 때문에 프로그래머 입장에서는 건너뛰어도 상관없다.3dx Max를 사용해 캐릭터의 폴리곤 메쉬를 만드는 간략한 방법일반적으로 모델링 패키지는 폴리곤 메쉬의 정점(vertex), 변(edge), 면(face)과 같은 요소들을 조작할 수 있는 다양한 기능을 제공한다.여러가지 모델링 방법 중 육면체로부터 시작해 해상도를 높여가면서 모양을 만들어 가는 방법이다.위상 구조 변경변을 선택한 후 이를 이어서 메쉬의 해상도를 높여간다.기하 변경메쉬의 정점들을 선택하고 이동하여 메쉬의 기하를 바꾸는 경우를 보여준다.이목구비 생성캐릭터의 눈을 만들기 위해 특정 폴리곤을 제거하고 메쉬의 해상도를 높여가는 과정을 보여준다.좌우대칭 구조 생성얼굴 한쪽을 복사해서 반대쪽에 붙였다.모델링 단계에서는 균형 잡힌 물체를 생성하기 위하여 한쪽 면에 작업을 집중하고 이를 복사해 반대쪽에 붙이는 일을 반복하곤 한다.좌·우측 메쉬 결합(welding)같은 위치를 가지는 정점 한 쌍을 하나의 정점으로 결합하는 과정을 통해 좌우측 메쉬를 통합할 수 있음을 보여준다.목 생성 과정메쉬의 목 부분이 만들어지는 것을 보여준다.이러한 작업을 계속하여 캐릭터 메쉬를 완성한 후 텍스처를 입히면 모델링이 완료된다.  위 그림의 캐릭터 모델은 삼각형 메쉬가 아닌 사각형 메쉬로 구성되었다.  이렇게 사각형 메쉬를 사용하면 여러 가지 모델링 작업을 쉽게 처리할 수 있다.  모델링 패키지는 이러한 사각형 메쉬와 동일한 기하를 가진 삼각형 메쉬를 즉각적으로 제공할 수 있으며, 렌더링을 위해서는 이 삼각형 메쉬를 사용할 수 있다.1.2.2 폴리곤 메쉬 표현 기법삼각형 리스트(triangle list): 삼각형을 구성하는 세 개의 정점을 순서대로 나열하는 것  삼각형 리스트는 삼각형 메쉬를 표현하는 가장 단순한 방법이다.정점 버퍼(vertex buffer): 정점들이 저장된 메모리 공간삼각형 리스트에서 n개의 삼각형을 가진 폴리곤 메쉬를 표현하기 위해서는 정점 버퍼에 3n개의 정점이 저장되어야 한다.정점 버퍼의 정점을 한 번에 세 개씩 읽어서 하나의 삼각형을 정의한다.상당히 직관적이지만, 데이터를 중복해서 저장한다는 단점이 있다.(1,1)의 좌표를 가지는 정점은 모든 삼각형들에 속하므로 정점 버퍼에 세 번 나타나게 된다.  이 표현법은 인덱스 없는(non-indexed) 삼각형 리스트라고 부른다.  이렇게 삼각형 메쉬를 표현하는 경우는 매우 드물다.삼각형 메쉬에서 거의 모든 정점은 여러 개의 삼각형들에 의해 공유된다.효율적인 메모리 사용을 위해 정점들을 중복 없이 저장하고, 이들을 가르키는 인덱스를 별도의 인덱스 버퍼(index buffer)에 저장한다.이 표현법은 인덱스 삼각형 리스트(indexed triangle list)라고 부른다.인덱스 삼각형 리스트 표현법은 정점 버퍼와 인덱스 버퍼를 필요로 한다.  정점 버퍼에는 일반적으로 정점 위치뿐만 아니라 정점의 노멀(normal), 텍스처 좌표(texture coordinates) 등 다양한 데이터가 포함 된다.  따라서 중복된 데이터를 제거함으로써 절약되는 정점 버퍼 공간은 인덱스 버퍼가 차지하는 공간 크기를 능가하게 된다.  렌더링 성능 향상에도 도움을 준다.삼각형 메쉬를 표현하는 또 하나의 방법은 삼각형 스트립(triangle strip)이다.삼각형 스트립. 첫 번째 삼각형을 제외한 모든 삼각형은 이전의 삼각형과 두 개의 정점을 공유한다.첫 번째 삼각형\\((t_1)\\)은 정점 버퍼의 첫 세 정점을 처리함으로써 렌더링된다. 두 번째 삼각형\\((t_2)\\)을 렌더링 하기 위해서는 첫 번째 삼각형의 마지막 두 정점 (0,0)과 (1,1)을 캐쉬로부터 읽어오고, 나머지 한 개의 정점 (1,0)만을 정점 버퍼에서 꺼내어 처리한다. 세 번째 삼각형도 마찬가지이다.  인덱스 삼각형 리스트보다 렌더링 성능이 낮다. 하지만 특정 응용에서 삼각형 리스트보다 선호되는 경우가 있다.  ex. 네 개의 정점으로 이루어진 사각형을 그릴 때1.2.3 노멀 벡터실세계 광원에서 나오는 빛은 물체 표현에서 반사되어 우리 눈에 도달하게 된다. 컴퓨터 그래픽스에서는 이러한 광원과 물체 표면 간 상호작용을 시뮬레이션한다.이를 조명(lighting 또는 illumination)이라 부른다.조명은 사진과 같은 사실적인 영상을 만들어 내는 데 있어 필수 불가결한 요소이다.  조명에 대한 내용은 5장에서 기술된다.조명 알고리즘에서는 실세계에서와 마찬가지로 물체 표면의 노멀(surface normal)이 핵심적인 역할을 한다.삼각형 \\(&lt;p_1, p_2, p_3&gt;\\)에서 첫 번째 정점\\((p_1)\\)과 두 번째 정점\\((p_2)\\)를 잇는 벡터를 \\(v_1\\)이라하고, 첫 번째 정점\\((p_1)\\)과 세 번째 정점\\((p_3)\\)을 잇는 벡터를 \\(v_2\\)라 하자.삼각형의 노멀은 \\(v_1\\)과 \\(v_2\\)의 외적(cross_product)을 이용해 다음과 같이 계산된다.\\[\\frac{v_1 \\times v_2}{\\lVert v_1 \\times v_2 \\rVert}\\]  컴퓨터 그래픽스에서 모든 노멀을 크기가 1인 단위 벡터(unit vextor)로 표현하는 것이 원칙이다.위의 식은 오른손 법칙을 따른다.정점의 순서가 바뀌면 삼각형 노멀의 방향이 달라진다.컴퓨터 그래픽스에서 노멀은 물체 바깥을 향하게 하는 것이 관례이다.따라서, 삼각형의 정점은 항상 반시계 방향(counter-clockwise)으로 정렬된다.  시계 방향(clockwise)로 정렬된 정점은 물체 안쪽을 향하는 노멀을 생성한다.삼각형의 정점들이 모두 반시계 방향으로 정렬되어 있는 인덱스 삼각형 리스트의 예하나의 폴리곤 메쉬가 주어졌을 때 그 정점 노멀들을 계산하는 정답은 없다.한 가지 방법은 하나의 정점을 공유하는 모든 삼각형 노멀들의 평균을 그 정점의 노멀로 정하는 것이다.정점 노멀은 해당 정점이 샘플링한 표면의 노멀에 해당한다.정점 노멀은 종종 해당 정점을 공유하는 삼각형들의 노멀의 평균으로 정의된다.  일반적으로 정점 노멀은 모델링 단계에서 계산되고 정점 버퍼에 저장되어 렌더링 단계로 넘겨진다."
  },
  
  {
    "title": "GitHub Pages 개설하기",
    "url": "/posts/github-pages/",
    "categories": "Blogging, Tutorial",
    "tags": "writing",
    "date": "2025-05-07 11:45:00 +0900",
    





    
    "snippet": "  언젠간 해야지 해야지 하던 숙제를 드디어 하는 기분입니다  velog, tistory, 네이버 블로그, GitHub Pages 등 여러 플랫폼을 고민하다가 내 친구 chatGPT의 추천으로 GitHub Pages로 선택하게 되었습니다.Jekyll 과 GitHub Pages우선 블로그를 만들때 제가 사용할 도구는 Jekyll입니다.  Jekyll은 ...",
    "content": "  언젠간 해야지 해야지 하던 숙제를 드디어 하는 기분입니다  velog, tistory, 네이버 블로그, GitHub Pages 등 여러 플랫폼을 고민하다가 내 친구 chatGPT의 추천으로 GitHub Pages로 선택하게 되었습니다.Jekyll 과 GitHub Pages우선 블로그를 만들때 제가 사용할 도구는 Jekyll입니다.  Jekyll은 루비 기반 정적 사이트 생성기입니다.제가 개설하면서 참고한 여러 블로그에서는 일단 루비와 Jekyll을 다운받고 시작했는데, 저는 그럴 필요가 없다고 생각해서 순서를 좀 바꿔보겠습니다.Jekyll 테마 선택제일 먼저 해야할건 Jekyll 테마를 선택하는 겁니다.다양한 사이트에서 테마를 선택할 수 있는데, 여러 사이트를 비교해 본 결과 굳이 그럴 필요가 없다고 생각합니다.그냥 제일 보기 편한 사이트에서 테마를 고르면 될거 같습니다.테마 사이트귀찮아서 링크 하나만 추가한거 맞아요. Jekyll theme 검색하면 많이 뜹니다  Demo를 누르면 미리보기가 가능하니 테마 고를때 참고하세요제가 처음에 고른 테마는 Not Pure Poole 테마입니다. 전체적으로 심플하면서 적당한 커스터마이징도 가능한 부분이 마음에 들었습니다.홍대병이 있어서 사람들이 많이 사용하지 않는 테마라는 점도 마음에 들었습니다.그리고 실제로 어느정도 꾸며서 블로그 포스팅 준비를 다 마친 상황이었습니다.하지만… 게시글 목록을 볼때 아래 페이지 번호를 표기해주는 것이 아닌 Older, Newer만 표기되는 점이 너무 마음에 안들었고, 제 실력으로는 수정이 불가능했습니다그래서 Chripy 테마로 다시 선택하게 되었습니다.유명한 테마는 역시 이유가 있는거 같습니다. 홍대병보단 커스터마이징이 우선인지라..Repository 생성, 빌드테마를 다 골랐으면 고른 테마의 Homepage를 누르면 됩니다.이제 GitHub Repository가 뜨면 그 Repository를 복사해서 제 GitHub Repository를 만들어주면 됩니다.  chripy테마는 해당 github의 chripy-starter repository를 가져오는걸 추천합니다여기서 fork해서 repository를 가져오는 방법이 있고, ZIP 파일로 다운을 받아서 Repository에 넣어주는 방법이 있습니다.처음 개설할때는 fork하는 방법을 사용했는데, GitHub 잔디가 안심겼습니다. 그 문제를 해결하는 과정도 귀찮았고, 어떤 블로그를 보면서 따라한거라 방법도 잘 기억이 안나기 때문에 ZIP 파일을 다운받도록 하겠습니다.다운을 받았으면 Repository를 생성하고 이름을 GitHub username.github.io로 설정해주시면 됩니다.그 후 다운받은 파일의 압축을 풀고 모두 복사해서 생성한 Repository에 넣어주면 됩니다.저는 착하니까 fork하는 방법도 포스팅하겠습니다.사실 별거 없습니다. fork 누르고 Repository 이름을 GitHub username.github.io 설정하면 됩니다.  이름을 잘못 설정했다면, setting에 들어가서 다시 변경할 수 있습니다.끝입니다. 간단하죠?GitHub 잔디를 심고싶다면 여기를 참고하세요.GitHub Pages 확인Reposity에서 Settings &gt; Pages에 들어가면 GitHub Pages 설정을 확인할 수 있습니다.보통 main 브랜치를 선택하고, 디렉토리는 / (root)로 설정하면 자동으로 블로그가 배포됩니다.https://github username.github.io로 접속해보면 블로그가 뜹니다.  1 ~ 5분 정도의 시간이 걸립니다.여기서 운명이 갈립니다.만약 고른 테마의 Demo와 같은 블로그가 개설이 되었다?축하드립니다. 당신은 아래의 기본 설정 변경하기 챕터로 넘어가셔도 됩니다.아래의 내용을 몰라도 블로그를 작성하는데 아무런 문제가 없습니다.혹시 이런식으로 뜨셨나요?축하드립니다. 당신은 저와 같은 깐깐한 입맛의 소유자입니다.github내에서 바로 빌드가 어려운 복잡한 테마의 경우 이런 식으로 뜬다고 합니다.따라하기 귀찮다면 그냥 간단한 테마로 새로 고르는 것도 추천드립니다Ruby 와 Jekyll 설치제 포스팅은 Chripy테마로 블로그를 생성한 과정입니다.  혹시 다른 테마를 선택하셨고, 제 포스팅을 참고했는데도 안된다면 당신의 친구 chatGPT한테 물어보세요.Chirpy를 쓰려면 Ruby와 Jekyll을 설치하고 Bundler도 같이 깔아야 합니다.Ruby 설치macOS에는 기본으로 탑재되어 있다고 하니, 다른 OS의 경우에만 설치해주시면 될거 같습니다.RubyInstaller 공식 사이트WITH DEVKIT 버전을 다운하시면 됩니다.설치하면서 MSYS2 옵션을 같이 설치하라고 뜨는데, 꼭 설치해야 합니다.설치하는 과정 스크린샷을 못 찍었는데, 참고 이미지 없어도 잘 하실거라 믿습니다.설치가 다 끝나고, 터미널(명령 프롬프트 혹은 Git Bash)을 열어서 아래의 코드를 각각 입력했을 때 버전이 나오면 성공입니다.ruby -vgem -vJekyll &amp; Bundler 설치Ruby가 설치되면, 터미널(또는 Git Bash)를 열고gem install jekyll bundler설치 다 되는데 몇 분 정도 걸릴 수 있습니다설치 이후 해야 할 것git clone으로 블로그 Repository를 컴퓨터로 가져오세요.  터미널에서 git clone하는 방법이나 GitHub Desktop을 사용해서 clone하는 방법중 편하신걸로 하세요# 프로젝트 폴더로 이동cd your-blog-repo# 필요한 gem 설치bundle install# 로컬에서 사이트 띄우기bundle exec jekyll serve그럼 http://localhost:4000 에서 블로그를 볼 수 있습니다.이때 에러없이 정상적으로 잘 뜬다면 GitHub Pages에도 정상 배포 가능한 상태입니다.GitHub Pages 배포하기터미널에서 다시 프로젝트 폴더로 이동한 후bundle exec jekyll build를 입력한다면 _site/ 폴더 안에 정적 사이트 파일이 생성이 됩니다.이 _site/폴더가 최종 배포용 파일 입니다.GitHub에 gh-pages 브랜치 만들기혹시 터미널을 닫거나 프로젝트 폴더를 벗어났다면, 다시 프로젝트 폴더로 이동해 줍니다.터미널에 아래의 코드를 입력해줍니다.git checkout --orphan gh-pagesgit reset --hard  gh-pages라는 비어있는 브랜치를 만드는 코드입니다.  main source 코드들과는 섞이면 안되기 때문에 비어있는 orphan 브랜치를 사용합니다.이제 _site/폴더 안으로 이동해 줍니다cd _site그 후 .git을 초기화 하고git initgit add .git commit -m \"Deploy my blog\"# who you are 이라고 뜬다면 그 아래의 git config로 뜨는 명령어 맨 뒤 \"\" 안의# 내용만 수정해서 둘 다다실행 후 위의 명령어부터 다시 입력해주세요.git branch -M gh-pagesgit remote add origin https://github.com/내계정명/내저장소명.gitgit push -f origin gh-pages‼️ 주의: origin 주소는 당신의 GitHub 저장소 주소로 바꿔줘야 합니다.  블로그 내용을 수정하고 재배포할때도 같은 코드를 입력하면 됩니다.GitHub Repository 설정 수정GitHub Repository로 가서Settings ➔ Pages 탭 들어가서아래 이미지와 같이 설정해 준 후 save 버튼을 누르면 끝납니다이제 조금만 기다리면 https://내계정명.github.io/주소로 블로그가 열립니다.기본 설정 변경하기블로그를 개인의 스타일로 바꾸기 위해 가장 먼저 수정해야 할 파일은 _config.yml입니다.사이트 이름, 이메일, 소개글, SNS 링크 등 여러 정보를 이 파일에서 바꿀 수 있습니다."
  },
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스] Ch01-1 게임 제작 파이프라인",
    "url": "/posts/3Dgraphics-ch01-1/",
    "categories": "",
    "tags": "graphics, pipeline",
    "date": "2025-04-26 21:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계1.1 게임 제작 파이프라인그래픽스 관점의 파이프라인  모델링 → 리깅 → 애니메이션 → 렌더링 → 후처리그래픽 아티스트: 모델링과 리깅 및 애니메이션의 전반부프로그래머: 애니메이션 후반부와 렌더링 및 후처리 작업  애니메이션 단계 = off-line 작업(그래픽 아티스트) + run-time 작업(프로그램)모델링 단계게임 환경 구성에 필요한 여러 가지 객체 만드는 단계ex. 슈팅게임에서는 군인, 총, 지형맵(terrain map) 등이러한 각 개체들은 폴리곤(polygon, 다각형)으로 구성되고, 이러한 물체를 폴리곤 메쉬(polygon mash)라 부른다.  게임에서 가장 많이 쓰이는 모델링 기법이다.시각적 사실성을 높여주는 텍스처(texture)의 제작 또한 매우 중요한 모델링 작업이다.  모델링 대상은 3차원 물체로 국한 되지 않는다.texture image 와 polygon mesh에 textrue 입힌 모습많이 사용하는 텍스처는 물체 표면 색상을 결정하는 비트맵 이미지(bitmap image)이다.리깅 단계애니메이션을 위해서는 골격(skeleton)을 구성한 후, 각각의 뼈의 움직임이 폴리곤 메쉬를 어떻게 변형하는지 정의해야 한다.ex. 군인 모델이 걷고 뛰기 위해서 허벅지 뼈가 움직일 때 허벅지를 구성하는 폴리곤이 따라서 움직이도록 설정이러한 과정을 리깅(rigging)이라고 부른른다.폴리곤 메쉬에 삽입된 골격삽입된 골격을 움직여 에니메이션 생성애니메이션 단계컴퓨터 게임 및 애니메이션에서는 조금씩 변화하는 연속적인 영상을 스크린 상에 빠르게 보여줌으로 움직임을 묘사한다.여기서 각각의 영상을 프레임(frame)이라고 부른다.  초당 60개의 프레임을 생성한다면 60fps(frames per second)물체의 애니메이션을 런타임에 재생할 때, 매 프레임마다 해당 물체의 위치와 방향을 계산해야 한다.역학(dynamics)을 처리하여 매 프레임마다 관련 물체들의 위치와 방향을 갱신한다.조명 상태와 시점(viewpoint) 또한 매 프레임마다 바뀔 수 있다.렌더링 단계각 프레임을 구성하는 모든 요소가 결정되면 렌더링(rendering) 모듈이 실행된다.  렌더링: 3차원 장면에서 2차원 영상(프레임)을 생성해 내는 과정위의 그림을 렌더링한 결과후처리 단계컴퓨터 게임의 최종 화면은 후처리(postprocessing)된 영상을 보여준다.시각적 사실성을 높이기 위한 작업은 모두 후처리 단계에서 이루어 진다.ex. 모션 블러(motion blur), 초점 심도(depth of field)런타임 애니메이션과 렌더링 및 후처리 단계는 게임 프로그램에 의해 실행된다.게임 프로그램은 그래픽스 API(Application Programming Interface)를 기반으로 작성된다.  API는 그래픽스 응용에 필수적인 함수들을 제공한다.  이러한 함수는 대부분 GPU 내에서 하드웨어로 구현 되어 있다.  그래픽스 API는 그래픽스 응용 프로그래밍에서 호출하는 함수를 GPU에서 실행 가능한 명령들로 바꿔주는 역할을 한다."
  },
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스] Ch01 폴리곤 메쉬",
    "url": "/posts/3Dgraphics-ch01/",
    "categories": "",
    "tags": "graphics, polygon_mesh, pipeline, modeling, vector, coordinate",
    "date": "2025-04-24 21:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.게임 프로그래밍을 위한 3차원 그래픽스Ch01 폴리곤 메쉬  1.1 게임 제작 파이프 라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계chap 01 폴리곤 메쉬게임 개발 과정  제작 전(pre-production):          게임 캐릭터 디자인      스토리라인 구성      스토리보드 제작      게임 디자인 문서 작성        제작(production):          게임 디자인 문서 수정      게임 프로그램      3차원 모델, 이미지, 애니메이션 데이터        제작 후(post-production):          결함과 버그를 통한 수정 (Debugging)      반복된 수정 후 최정 버전 산출 (+ Optimization)      이 책은 게임 제작 단계의 3차원 그래픽스 내용을 다룬다3차원 그래픽스는 모델링(modeling)으로부터 시작된다."
  },
  
  {
    "title": "[게임 프로그래밍을 위한 3차원 그래픽스]",
    "url": "/posts/3Dgraphics/",
    "categories": "Graphics, Study Notes",
    "tags": "graphics",
    "date": "2025-04-24 15:00:00 +0900",
    





    
    "snippet": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.목차Ch01 폴리곤 메쉬  1.1 게임제작 파이프라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계Ch02 정점 처...",
    "content": "  『게임 프로그래밍을 위한 3차원 그래픽스』 - 한정현 저. 홍릉과학출판사 책을 공부한 내용입니다.  http://media.korea.ac.kr/books/ 해당 링크에 첨부된 자료를 이용하여 작성된 글입니다.목차Ch01 폴리곤 메쉬  1.1 게임제작 파이프라인  1.2 폴리곤 메쉬  1.3 모델 내보내기와 불러오기  1.4 좌표계Ch02 정점 처리  2.1 월드 변환  2.2 뷰 변환  2.3 정점별 조명  2.4 투영 변환Ch03 래스터화  3.1 클리핑  3.2 원근 나눗셈  3.3 뒷면 제거  3.4 좌표계  3.5 뷰포트 변환  3.6 스캔 변환  3.7 응용 사례: 피킹Ch04 프래그먼트 처리와 출력 병합  4.1 텍스처링  4.2 출력 병합  4.3 Z-컬링Ch05 조명 및 쉐이더  5.1 퐁 조명 모델  5.2 쉐이더와 쉐이딩 언어  5.3 파이프라인에서의 조명  5.4 전역 조명Ch06 매개변수 곡선과 곡면  6.1 매개변수 곡선  6.2 응용 사례: 카메라 경로  6.3 베지어 곡면Ch07 쉐이더 모델  7.1 쉐이더 모델 4와 기하 쉐이더  7.2 응용 사례: 동적 파티클 시스템  7.3 쉐이더 모델 5와 테쎌레이션  7.4 응용 사례: PN-삼각형Ch08 이미지 텍스처링  8.1 텍스처 어드레싱 모드  8.2 텍스처 필터링  8.3 밉매핑  8.4 비등방형 필터링Ch09 범프 매핑  9.1 하이트 필드  9.2 노멀 매핑  9.3 탄젠트 공간 노멀 매핑  9.4 노멀맵 제작  9.5 패럴랙스 매핑  9.6 변위 매핑Ch10 고급 텍스처링 기법  10.1 환경 매핑  10.2 라이트 매핑  10.3 쉐도우 매핑  10.4 앰비언트 오클루전  10.5 미뤄진 쉐이딩Ch11 캐릭터 애니메이션  11.1 키프레임 애니메이션  11.2 회전  11.3 계층적 모델링과 공간 이전  11.4 기구학  11.5 스키닝과 키프레임 애니메이션  11.6 역기구학Ch12 물리 기반 시뮬레이션  12.1 페널티 기법  12.2 충격량 기법  12.3 충돌 검사"
  }
  
]

